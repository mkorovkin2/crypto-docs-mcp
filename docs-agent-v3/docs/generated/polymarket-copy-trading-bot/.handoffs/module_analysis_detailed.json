{
  "modules": [
    {
      "name": "src",
      "analysis": "Excellent. Here is a detailed architectural analysis of the `src` module.\n\n---\n\n### 1. MODULE RESPONSIBILITY\nThe `src` module represents the entire application core for the Polymarket Trading Bot. Its primary responsibility is to orchestrate all the components required for automated trading. It acts as the central nervous system, integrating market data acquisition, strategic decision-making, risk management, and trade execution into a cohesive, event-driven system.\n\nIt is not a library or a sub-component but the main application logic itself. Its goal is to run continuously, identify trading opportunities based on pre-defined strategies, and manage the entire lifecycle of a trade from signal generation to position management, all while adhering to strict risk controls.\n\n### 2. PUBLIC API\nAs the main application module, its \"public API\" consists of its primary entry point and its configuration surface, which defines how an operator interacts with and launches the bot.\n\n*   **Key Classes/Functions:**\n    *   `PolymarketTradingBot` (from `src/index.ts`): This is the main orchestrator class. It instantiates and wires together all other components (managers, scanners, API clients). Its `start()` method kicks off the bot's operations.\n    *   `main()` (from `src/index.ts`): The application's entry point. It handles the initial setup, instantiates `PolymarketTradingBot`, and starts it.\n\n*   **Entry Points:**\n    *   The definitive entry point is the `main` function in `src/index.ts`. This is what would be executed by the Node.js runtime (e.g., `node dist/index.js`).\n\n*   **Configuration Options:**\n    *   The module's behavior is entirely configured via environment variables, which are parsed and validated by `src/config/env.ts`. This file exposes a single `config` object that provides strongly-typed access to all settings, such as:\n        *   API credentials (`PRIVATE_KEY`, `POLY_AUTH_TOKEN`).\n        *   Trading parameters (`MAX_TRADE_SIZE_USD`, `SLIPPAGE_TOLERANCE`).\n        *   Risk parameters (`MAX_EXPOSURE_USD`, `DAILY_PROFIT_TARGET`, `EMERGENCY_STOP_LOSS_PCT`).\n        *   Market scanning criteria (`MIN_MARKET_LIQUIDITY`, `MIN_MARKET_VOLUME_24H`).\n        *   Strategy-specific settings.\n\n### 3. DEPENDENCIES\nThe module relies on a mix of external libraries for core functionalities and internal modules for separating concerns.\n\n*   **External Libraries:**\n    *   `axios` (in `src/api/polymarket.ts`): Used for making HTTP REST API calls to the Polymarket backend. This is essential for fetching market lists, user positions, and executing orders.\n    *   `decimal.js` (in `src/utils/math.ts`): Used for all financial and mathematical calculations. **This is a critical dependency** to avoid floating-point precision errors common with standard JavaScript numbers, ensuring accuracy in pricing, P&L, and risk calculations.\n    *   `pino` (in `src/utils/logger.ts`): A high-performance logging library used for structured, asynchronous logging throughout the application.\n    *   `ws` (or a similar library, implied by `src/api/websocket.ts`): Used to manage the persistent WebSocket connection for receiving real-time order book data.\n    *   `events` (Node.js built-in): The `EventEmitter` class is the backbone of the internal communication system, used by nearly every major component.\n\n*   **Other Internal Modules:**\n    *   The architecture is highly modular, with `index.ts` acting as the central integrator.\n    *   **`index.ts` (`PolymarketTradingBot`) depends on:**\n        *   `config/env.ts`: For all configuration.\n        *   `api/polymarket.ts` & `api/websocket.ts`: For all communication with the exchange.\n        *   `market/marketScanner.ts`: To discover and prioritize tradable markets.\n        *   `trader/*` (`RiskManager`, `PositionManager`, `OrderManager`): To manage the entire trading lifecycle.\n        *   `utils/*`: For logging and mathematical operations.\n    *   **The `trader` components depend on:**\n        *   `RiskManager` is a dependency for `OrderManager` to validate trades before execution.\n        *   `PositionManager` and `OrderManager` depend on `PolymarketAPI` to sync state with the exchange.\n    *   **Why these dependencies exist:** This structure follows the principle of Separation of Concerns. The API layer is isolated from trading logic, risk management is a distinct service, and strategies are separate from the core orchestration, making the system easier to maintain, test, and extend.\n\n### 4. DESIGN PATTERNS\nThe module's architecture is heavily influenced by several key design patterns that promote decoupling, flexibility, and maintainability.\n\n*   **Observer Pattern:** This is the most dominant pattern, implemented via Node.js's `EventEmitter`. It forms the communication backbone of the system.\n    *   **Example:** `MarketScanner` emits a `scanComplete` event with a list of markets. `PolymarketTradingBot` listens for this event to trigger the strategy analysis phase. `OrderManager` emits an `orderFill` event, which `PositionManager` and `RiskManager` listen to in order to update their respective states. This decouples the components; the emitter does not need to know who its subscribers are.\n\n*   **Strategy Pattern:** The system is designed to accommodate different trading algorithms.\n    *   **Example:** The `insights` for `index.ts` explicitly"
    },
    {
      "name": "src.config",
      "analysis": "Of course. Here is a detailed analysis of the `src.config` module.\n\n---\n\n### **Detailed Module Analysis: `src.config`**\n\n#### 1. MODULE RESPONSIBILITY\n\nThe core responsibility of the `src.config` module is to act as the **single source of truth for all application configuration**. It achieves this by performing three critical tasks:\n\n1.  **Loading:** It reads configuration values from the runtime environment (i.e., `process.env`).\n2.  **Parsing & Type Coercion:** It transforms the raw string values from the environment into strongly-typed application-level primitives like numbers, booleans, and decimals.\n3.  **Validation:** It ensures that all required configuration is present and valid at application startup, preventing runtime errors due to misconfiguration.\n\nBy centralizing this logic, the module decouples the rest of the application from the complexities of environment variable management, providing a stable, predictable, and type-safe interface for accessing configuration settings.\n\n#### 2. PUBLIC API\n\nThe public API of this module is intentionally minimal and focused. Its primary purpose is to expose the final, validated configuration object.\n\n*   **Key Exports:** The main export is a singleton-like constant, likely named `config`. This object contains all the parsed and validated application settings.\n*   **Entry Points:** Other modules consume this module by importing the `config` object.\n    ```typescript\n    import { config } from 'src/config/env';\n\n    // Example usage\n    const serverPort = config.PORT;\n    const dbUrl = config.DATABASE_URL;\n    ```\n*   **Configuration Options:** The properties of the exported `config` object define the available settings. While the full interface is not provided, it would typically include properties such as:\n    *   `NODE_ENV`: The application environment (e.g., 'development', 'production').\n    *   `PORT`: The port number for the web server.\n    *   `DATABASE_URL`: The connection string for the database.\n    *   `LOG_LEVEL`: The configured logging verbosity.\n    *   `API_KEY`: A third-party service API key.\n    *   `FEATURE_FLAG_X`: A boolean flag to enable or disable a feature.\n\nThe helper functions (`getEnvVar`, `getEnvNumber`, etc.) are likely internal to the module and not exported, as their purpose is to construct the main `config` object.\n\n#### 3. DEPENDENCIES\n\nThis module is designed to be a foundational, low-level component with minimal dependencies.\n\n*   **External Libraries:**\n    *   Based on the provided information, there are no explicit external library dependencies listed.\n    *   However, a module like this almost universally uses the `dotenv` library to load variables from a `.env` file during local development. This dependency would be part of the development toolchain rather than a runtime dependency in production.\n*   **Other Internal Modules:**\n    *   This module should have **zero dependencies** on other internal application modules (e.g., `src.services`, `src.controllers`). This is a critical architectural characteristic. It must be able to be initialized first, without needing any other part of the application to be ready.\n*   **Runtime Dependencies:**\n    *   The module has a fundamental dependency on the **Node.js runtime**, specifically the global `process.env` object, which is its primary source of data.\n\nThe dependency structure is intentional: it makes the `config` module a stable foundation that other modules can rely on without creating circular dependencies.\n\n#### 4. DESIGN PATTERNS\n\nThe module effectively employs several well-established patterns.\n\n*   **Configuration Object Pattern:** This is the primary pattern. All configuration is consolidated into a single, immutable object (`config`). This centralizes access, makes it easy to mock for testing, and provides a clear contract for what settings the application requires.\n*   **Singleton Pattern (Implicit):** The exported `config` object is effectively a singleton. It is created once when the module is first imported and then shared across the entire application. This ensures that all parts of the system are using the exact same configuration values throughout the application's lifecycle.\n*   **Factory/Utility Functions:** The functions `getEnvVar`, `getEnvDecimal`, `getEnvBoolean`, and `getEnvNumber` act as small, specialized factories. Each is responsible for the \"creation\" of a specific data type from a raw string input. They encapsulate the logic for:\n    *   Retrieving a value by its key.\n    *   Handling missing values (throwing an error for required variables).\n    *   Parsing the string into the correct type (e.g., `'true'` becomes `true`).\n*   **Fail-Fast Principle:** The `validateConfig` function embodies this principle. By validating the entire configuration at startup, the application fails immediately if the environment is misconfigured. This is far preferable to encountering a `TypeError` or `ReferenceError` deep within the application logic at an unpredictable time.\n\n#### 5. DATA FLOW\n\nThe data flow is linear, unidirectional, and synchronous, occurring at application startup.\n\n1.  **Input:** The process begins with the raw, untyped key-value pairs in the `process.env` object, which is populated by the host environment (or a `.env` file via `dotenv`).\n2.  **Transformation:**\n    *   The module's initialization logic calls the various `getEnv...` helper functions for each expected configuration variable (e.g., `PORT`, `DATABASE_URL`).\n    *   Each helper function reads a specific key from `process.env`, validates its existence, and performs type coercion (e.g., `parseInt(process.env.PORT)`).\n    *   The results of these calls are aggregated into a single, preliminary configuration object.\n    *   This object is then passed to the `validateConfig` function for final, potentially cross-variable, validation checks.\n3.  **Output:** If validation succeeds, the final, immutable, and strongly-typed `config` object is exported. If validation fails, an error is thrown, halting the application's startup process. This validated object is then imported and consumed by other modules.\n\n#### 6. COUPLING ASSESSMENT\n\n*   **Efferent Coupling (Outgoing): Low.** The module has virtually no outgoing dependencies on other application modules. Its only significant dependency is on the Node.js `process.env` global.\n*   **Afferent Coupling (Incoming): High.** Many, if not all, other modules in the application will depend on `src.config` to retrieve settings.\n\nThis coupling profile is **highly appropriate and desirable** for a configuration module. It is a stable, foundational component that provides a service to the rest of the system. Its stability is paramount, as changes to its public API (`config` object) would have a ripple effect across the application.\n\n#### 7. COHESION ASSESSMENT\n\nThe module demonstrates **very high cohesion**.\n\n*   **Single Responsibility:** All functions within `src/config/env.ts` (`getEnvVar`, `getEnvNumber`, `validateConfig`) are exclusively focused on the single responsibility of loading, parsing, and validating environment variables.\n*   **No Mixed Concerns:** The module does not contain business logic, database queries, API clients, or any other unrelated concerns. It does one thing and does it well.\n\nThis high cohesion makes the module easy to understand, maintain, and test in isolation.\n\n#### 8. POTENTIAL ISSUES & SUGGESTED IMPROVEMENTS\n\nWhile the current architecture is solid, there are areas for improvement and potential technical debt to consider as the"
    },
    {
      "name": "src.trader",
      "analysis": "Of course. Here is a detailed analysis of the `src.trader` module's architecture.\n\n### **Module Analysis: `src.trader`**\n\n---\n\n#### **1. MODULE RESPONSIBILITY**\n\nThe `src.trader` module serves as the **operational core and execution engine** of the trading system. Its primary responsibility is to manage the entire lifecycle of a trade, from initial validation to final state tracking. It translates abstract trading decisions (signals) into concrete actions (orders) while operating within a strict set of rules.\n\nThis encompasses three distinct but interconnected concerns, each handled by a dedicated class:\n*   **Decision Gating (`RiskManager`):** Determines *if* a proposed trade is permissible based on predefined risk parameters like maximum loss, exposure limits, and market-specific cooldowns.\n*   **State Tracking (`PositionManager`):** Maintains an accurate, real-time representation of the system's current holdings and their financial status (unrealized P&L). It answers the question, \"What do we own right now?\"\n*   **Action Execution (`OrderManager`):** Handles the mechanics of placing, monitoring, and confirming orders with the external exchange. It is responsible for the \"how\" of trade execution.\n\nIn essence, this module is the bridge between trading strategy (which exists outside this module) and the live market.\n\n---\n\n#### **2. PUBLIC API**\n\nThe module exposes its functionality through the public interfaces of its three core classes. Other modules interact with this module by instantiating these classes and using their methods and events.\n\n**Key Classes / Entry Points:**\n\n*   **`OrderManager`**: This is the primary entry point for initiating trading activity.\n    *   `constructor(polymarketApi, riskManager)`: Requires dependencies to be injected for operation.\n    *   `executeSignal(signal: TradeSignal)`: The main command method. An external strategy module would call this to request a trade.\n    *   **Events Emitted**: `orderFill`, `orderCancelled`, `orderExpired`. These events form a crucial part of the public API, allowing other modules to react to the outcome of an order.\n\n*   **`PositionManager`**: This class provides access to the system's current portfolio state.\n    *   `constructor(polymarketApi, riskManager)`: Requires dependencies for fetching and validating position data.\n    *   `syncPositions()`: A method to force a full reconciliation of positions with the exchange.\n    *   `getPosition(marketId: string)`: A getter for a specific position.\n    *   **Events Emitted**: `positionsSynced`, `positionUpdated`. These are critical for notifying other components, especially `RiskManager`, of state changes.\n\n*   **`RiskManager`**: This class exposes risk status and validation logic.\n    *   `constructor(config: RiskConfig)`: Takes a configuration object defining risk rules.\n    *   `checkTrade(signal: TradeSignal)`: An internal-facing method (called by `OrderManager`) but conceptually part of the module's logic.\n    *   **Events Emitted**: `emergencyStopLoss`, `dailyStatsUpdate`, `circuitBreaker`. These are high-importance events for alerting the wider system (e.g., a UI, a notification service, or a master control process) of critical risk events.\n\n**Configuration Options:**\n\nConfiguration is primarily injected into the `RiskManager` via a `RiskConfig` object, which would likely contain parameters such as:\n*   `maxDailyLossPercentage`\n*   `maxTotalExposure`\n*   `marketExposureLimits`\n*   `circuitBreakerThresholds`\n\n---\n\n#### **3. DEPENDENCIES**\n\n**External Libraries / APIs:**\n\n*   **`EventEmitter` (Node.js core):** All three classes extend `EventEmitter`. This is a fundamental dependency that enables the event-driven, loosely-coupled communication between them and with the rest of the application.\n*   **`PolymarketAPI`:** This is a critical external dependency. It's an abstraction layer (likely a dedicated client/SDK) for interacting with the Polymarket exchange's API.\n    *   *Why it exists:* `OrderManager` needs it to place and cancel orders. `PositionManager` needs it to fetch the current state of open positions. This dependency isolates all direct network communication with the exchange.\n\n**Other Internal Modules:**\n\nThe classes within this module are highly interdependent, forming a cohesive unit.\n*   **`OrderManager` depends on `RiskManager`:** Before placing any trade, `OrderManager` must consult `RiskManager` to ensure the trade does not violate any rules. This is a classic Gatekeeper pattern.\n*   **`RiskManager` depends on `PositionManager`:** To make informed decisions, `RiskManager` needs real-time data on current positions, exposure, and unrealized P&L, which it gets from `PositionManager`.\n*   **`PositionManager` listens to `OrderManager`:** The `PositionManager` subscribes to the `orderFill` event from the `OrderManager`. This is how it knows to update its internal state when a new position is opened or an existing one is modified, without needing to poll the API constantly.\n\nThis circular dependency (`OrderManager` -> `RiskManager` -> `PositionManager` -> `OrderManager`) is managed cleanly through events and dependency injection, making it a controlled and necessary feature of the design rather than a problematic anti-pattern.\n\n---\n\n#### **4. DESIGN PATTERNS**\n\nThe module's architecture is heavily influenced by established design patterns that promote separation of concerns, testability, and reactive programming.\n\n*   **Observer Pattern:** This is the most prominent pattern, implemented via `EventEmitter`.\n    *   **Publisher/Subject:** `OrderManager`, `PositionManager`, `RiskManager`.\n    *   **Subscriber/Observer:** The classes subscribe to each other's events (`PositionManager` listens to `OrderManager`). External modules (UIs, logging, notification services) can also subscribe.\n    *   **Benefit:** Decouples the components. `OrderManager` doesn't need to know *"
    },
    {
      "name": "src.utils",
      "analysis": "Of course. Here is a detailed analysis of the `src.utils` module architecture.\n\n---\n\n### **Detailed Architectural Analysis: `src.utils` Module**\n\n#### 1. MODULE RESPONSIBILITY\nThe core responsibility of the `src.utils` module is to provide foundational, cross-cutting utilities that are shared across the entire application. It encapsulates common, reusable logic that is not specific to any single business domain feature but is required by many.\n\nThis responsibility is divided into two distinct, high-cohesion sub-domains:\n*   **`src/utils/math.ts`**: Provides a centralized, reliable, and high-precision toolkit for all mathematical operations, with a stated focus on financial, statistical, and betting calculations. Its primary role is to prevent logic duplication and ensure consistency and accuracy (by using a decimal library) in calculations throughout the system.\n*   **`src/utils/logger.ts`**: Provides a single, pre-configured, application-wide logging instance. Its responsibility is to standardize how logging is performed, ensuring that all log messages have a consistent format, level, and output destination.\n\nIn essence, this module acts as a foundational layer, offering stable and generic services to higher-level application modules.\n\n#### 2. PUBLIC API\nThe module exposes two primary assets to the rest of the application, each from its respective file.\n\n*   **File: `src/utils/math.ts`**\n    *   **Key Class:** `MathUtils`\n    *   **Entry Point:** Other modules will use `import { MathUtils } from 'src/utils/math';`.\n    *   **API Surface:** The public API consists entirely of the `static` methods within the `MathUtils` class. While the specific methods aren't listed, based on the purpose, they would likely include functions for:\n        *   Financial calculations (e.g., `MathUtils.calculateInterest(...)`, `MathUtils.toDecimal(...)`)\n        *   Statistical analysis (e.g., `MathUtils.calculateStandardDeviation(...)`, `MathUtils.mean(...)`)\n        *   Betting odds conversion (e.g., `MathUtils.americanToDecimal(...)`, `MathUtils.calculateImpliedProbability(...)`)\n    *   **Configuration:** This class is likely stateless and requires no configuration.\n\n*   **File: `src/utils/logger.ts`**\n    *   **Key Function/Instance:** A pre-configured logger instance, likely exported as `logger`.\n    *   **Entry Point:** Other modules will use `import { logger } from 'src/utils/logger';`.\n    *   **API Surface:** The API is that of the underlying `pino` logger instance, which includes methods like:\n        *   `logger.info(obj, msg)`\n        *   `logger.warn(obj, msg)`\n        *   `logger.error(obj, msg)`\n        *   `logger.debug(obj, msg)`\n        *   `logger.child(bindings)` to create contextual sub-loggers.\n    *   **Configuration:** The configuration is internal to the `logger.ts` file. The consuming modules do not configure the logger; they simply use the provided instance.\n\n#### 3. DEPENDENCIES\nThe module's dependencies are minimal and foundational, which is ideal for a utility module.\n\n*   **External Libraries:**\n    *   **`decimal.js` (or similar, inferred from \"deci\"):** This dependency exists in `math.ts` to handle arbitrary-precision arithmetic. Standard JavaScript numbers (IEEE 754 floating-point) are inadequate for financial and many statistical calculations due to precision errors. This library is critical for the correctness of the `MathUtils` class.\n    *   **`pino`:** This dependency exists in `logger.ts`. It is a high-performance, structured logging library. It is chosen over `console.log` to provide essential features for production applications, such as log levels, JSON output for easier parsing by log aggregators, and asynchronous writing to avoid blocking the event loop.\n\n*   **Other Internal Modules:**\n    *   Based on the provided information, this module has **zero dependencies** on other internal application modules (e.g., `src/services`, `src/controllers`). This is a sign of a well-architected foundational module. It provides services *to* the application; it does not consume them.\n\n#### 4. DESIGN PATTERNS\nThe module effectively uses several common and practical design patterns.\n\n*   **Utility Class (`math.ts`):** `MathUtils` is a textbook example of the Utility (or Helper) Class pattern. It groups related functions under a single class namespace. All methods are `static`, meaning no instance of `MathUtils` is ever created. This pattern is used for its simplicity and clear organization of stateless functions.\n\n*   **Singleton (`logger.ts`):** The exported `logger` instance is an implementation of the Singleton pattern. While it doesn't use a traditional `class Logger { static getInstance() }` structure, the Node.js/ESM module cache ensures that any module importing from `src/utils/logger.ts` receives the *exact same instance*. This is crucial for a logger, as it guarantees a single point of configuration and a unified output stream for the entire application.\n\n*   **Strategy (Implicit in `math.ts`):** As noted in the insights, each static method in `MathUtils` represents a concrete algorithm or \"strategy\" for a specific calculation. This isolates the implementation details of each calculation, making the class easy to test and extend with new calculation strategies without affecting existing ones.\n\n*   **Configuration Object (`logger.ts`):** The `pino` logger is initialized using a configuration object. This pattern enhances readability and maintainability by using named properties (`{ level: 'info', transport: ... }`) instead of a long list of constructor arguments.\n\n#### 5. DATA FLOW\nData flow through this module is unidirectional and simple, characteristic of utility functions.\n\n*   **`MathUtils`:**\n    *   **Input:** Receives primitive data types (numbers, strings) as arguments to its static methods from service layers or other business logic components.\n    *   **Transformation:** Internally, it converts these inputs into high-precision decimal objects, performs the requested mathematical operation, and computes a result. The transformations are pure; they produce no side effects.\n    *   **Output:** Returns the calculated result (e.g., a `Decimal` object, a formatted number, or a boolean) back to the calling function.\n\n*   **`logger`:**\n    *   **Input:** Receives objects and/or strings from any part of the application that needs to log an event.\n    *   **Transformation:** The `pino` instance takes the input, adds metadata (timestamp, log level, hostname, pid), and serializes the entire payload into a structured format (typically a single line of JSON).\n    *   **Output:** The transformed data (the log line) is sent to its configured output destination, which is a side effect. This destination is typically `stdout`, which can then be redirected to"
    },
    {
      "name": "src.api",
      "analysis": "Of course. Here is a detailed architectural analysis of the `src.api` module.\n\n---\n\n### 1. MODULE RESPONSIBILITY\n\nThe core responsibility of the `src.api` module is to serve as a dedicated **gateway** and **abstraction layer** for all communication with the external Polymarket service. It encapsulates the complexities of network requests, authentication, and data format translation, providing the rest of the application with a clean, consistent interface.\n\nThis responsibility is bifurcated into two distinct communication protocols:\n\n1.  **Request-Response Communication (REST):** Handled by `PolymarketAPI` in `polymarket.ts`, this covers stateful, user-initiated actions like fetching market data, retrieving account balances, and placing or canceling orders.\n2.  **Real-Time Streaming Communication (WebSocket):** Handled by `PolymarketWebSocket` in `websocket.ts`, this covers the persistent connection required for receiving unsolicited, real-time data pushes from the server, specifically orderbook updates.\n\nIn essence, this module isolates the rest of the application from the implementation details of the Polymarket API, ensuring that if the external API changes, the required modifications are confined to this single module.\n\n### 2. PUBLIC API\n\nThe module exposes two primary classes as its public interface, intended to be instantiated and used by other modules in the system.\n\n**`PolymarketAPI` (from `src/api/polymarket.ts`)**\n\n*   **Entry Point:** The `PolymarketAPI` class itself. It is likely instantiated with configuration such as API credentials, a private key for signing, and the base URL for the REST API.\n*   **Key Methods (Inferred from purpose):**\n    *   `getMarket(marketId: string)`: Fetches detailed information for a specific market.\n    *   `placeOrder(params: PlaceOrderParams)`: Submits a new order to the orderbook.\n    *   `cancelOrder(orderId: string)`: Cancels an existing order.\n    *   `getPositions()`: Retrieves the user's current positions across all markets.\n    *   `getTrades()`: Fetches the user's trade history.\n*   **Configuration:** The constructor would likely accept an object containing an `axios` instance or configuration details (e.g., `baseURL`, `headers`, `timeout`) to manage HTTP requests.\n\n**`PolymarketWebSocket` (from `src/api/websocket.ts`)**\n\n*   **Entry Point:** The `PolymarketWebSocket` class. It is likely instantiated with the WebSocket URL.\n*   **Key Methods & Events (Inferred from purpose & insights):**\n    *   `connect()`: Initiates the WebSocket connection.\n    *   `disconnect()`: Closes the connection gracefully.\n    *   `subscribe(marketId: string)`: Sends a subscription message to the server to start receiving orderbook updates for a specific market.\n    *   `unsubscribe(marketId: string)`: Stops receiving updates for a market.\n    *   **Event Emitter Interface:** The class acts as an event emitter. The primary way other modules consume data is by listening to events.\n        *   `on('orderbook', (data: OrderbookUpdate) => { ... })`: Emits real-time orderbook data for a subscribed market.\n        *   `on('connect', () => { ... })`: Emits when the connection is successfully established.\n        *   `on('disconnect', (reason: string) => { ... })`: Emits when the connection is lost.\n\n### 3. DEPENDENCIES\n\n**External Libraries:**\n\n*   **`axios`:** Used by `PolymarketAPI` in `polymarket.ts`.\n    *   **Reason:** It is the de-facto standard for making promise-based HTTP requests in Node.js and the browser. It simplifies handling requests, responses, headers, and errors for REST API communication.\n*   **A WebSocket Client Library (e.g., `ws` for Node.js or native browser `WebSocket`):** Used by `PolymarketWebSocket` in `websocket.ts`.\n    *   **Reason:** This is fundamental for establishing and managing the persistent, bidirectional WebSocket connection required for real-time data streams.\n\n**Other Internal Modules:**\n\n*   Based on the provided information, the `src.api` module appears to be a foundational layer with **no dependencies on other internal application modules**. This is excellent architectural practice, as it makes the module highly reusable and places it at the base of the dependency tree. Other modules (e.g., `src.trading`, `src.ui`) will depend on `src.api`, but not vice-versa.\n\n### 4. DESIGN PATTERNS\n\nThe module effectively employs several key design patterns to manage its responsibilities.\n\n*   **Facade Pattern:** The `PolymarketAPI` class is a textbook example of a Facade. It provides a simplified, high-level interface (`placeOrder`, `getMarket`) that hides the underlying complexity of constructing and sending authenticated HTTP requests using `axios`, handling JSON serialization/deserialization, and managing API-specific headers.\n*   **Observer Pattern:** The `PolymarketWebSocket` class is a clear implementation of the Observer pattern.\n    *   **Subject:** `PolymarketWebSocket` is the subject. It maintains a state (the orderbook data) and notifies observers when that state changes.\n    *   **Observers:** Any other part of the application that listens to its events (e.g., `ws.on('orderbook', ...)`) is an observer.\n    *   **Benefit:** This decouples the low-level WebSocket message handling from the business logic that needs to react to orderbook updates, allowing multiple, independent components to consume the same real-time data stream.\n*   **State Pattern (Implicit):** The `PolymarketWebSocket` class implicitly uses the State pattern to manage the connection lifecycle. Its behavior changes based on its internal state (`CONNECTING`, `OPEN`, `CLOSED`). For example, a call to `subscribe()` will only succeed if the state is `OPEN`; it might be queued if `CONNECTING` or fail if `CLOSED`. This logic is essential for a robust WebSocket client.\n\n### 5. DATA FLOW\n\n**Outbound Flow (Application -> Polymarket):**\n\n1.  **Initiation:** A higher-level module (e.g., a trading bot) calls a method on an instance of `PolymarketAPI` (e.g., `placeOrder(...)`) or `PolymarketWebSocket` (e.g., `subscribe(...)`).\n2.  **Transformation:** Inside the `src.api` module, the input parameters are transformed into the data format required by the Polymarket API. For `PolymarketAPI`, this means creating a JSON request body and setting appropriate HTTP headers. For `PolymarketWebSocket`, this means creating a specific JSON message for the subscription command.\n3.  **Transmission:** The formatted data is sent over the network using `axios` (for REST) or the WebSocket client (for WebSocket messages).\n\n**Inbound Flow (Polym"
    },
    {
      "name": "src.market",
      "analysis": "Of course. Here is a detailed architectural analysis of the `src.market` module.\n\n---\n\n### 1. MODULE RESPONSIBILITY: What is this module's core responsibility in the system?\n\nThe `src.market` module serves as the system's primary **market intelligence and analysis engine**. Its core responsibility is to bridge the gap between raw data from the Polymarket platform and actionable insights required by other parts of the system (e.g., a trading execution module).\n\nThis responsibility is bifurcated into two distinct, complementary functions:\n\n1.  **Market Discovery and Prioritization (`MarketScanner`):** This is the \"macro\" view. It scans the entire universe of available markets on Polymarket, filters them against a set of criteria (e.g., volume, liquidity, time to resolution), and then scores the remaining candidates to produce a ranked list of \"tradable\" opportunities. It answers the question: **\"Which markets should we be paying attention to right now?\"**\n\n2.  **Deep Orderbook Analysis (`OrderbookEngine`):** This is the \"micro\" view. Once a specific market of interest is identified (likely by the `MarketScanner`), the `OrderbookEngine` connects to its real-time data stream. It maintains the live orderbook, calculates critical financial metrics (VWAP, liquidity imbalance, spread), and generates analytical signals. It answers the question: **\"What is happening inside this specific market right now?\"**\n\nIn essence, this module acts as the sensory organ of the application, observing the external market environment and translating that raw data into a structured, analytical format.\n\n### 2. PUBLIC API: What does this module expose to other modules?\n\nThe module exposes two primary classes as its public API, intended to be instantiated and used by other modules.\n\n**`MarketScanner` (`src/market/marketScanner.ts`)**\n*   **Key Class:** `MarketScanner`\n*   **Entry Points:**\n    *   `new MarketScanner(config)`: The constructor would likely take a configuration object specifying scanning intervals, filtering criteria (e.g., minimum volume, maximum days to resolution), and scoring weights.\n    *   `start()` / `stop()`: Methods to begin and end the continuous scanning process.\n    *   `on('scanComplete', (markets: ScoredMarket[]) => { ... })`: This is the primary output mechanism. As an `EventEmitter`, it allows consumers to subscribe to the results of each scan cycle. The payload would be an array of scored and ranked market objects.\n*   **Configuration Options:**\n    *   Scan interval (e.g., every 60 seconds).\n    *   Filtering thresholds (min volume, min liquidity, etc.).\n    *   Parameters for the `calculateMarketScore` logic.\n\n**`OrderbookEngine` (`src/market/orderbook.ts`)**\n*   **Key Class:** `OrderbookEngine`\n*   **Entry Points:**\n    *   `new OrderbookEngine(marketId, config)`: The constructor takes the specific market to monitor and a configuration object for its analytical calculations.\n    *   `connect()` / `disconnect()`: Methods to manage the WebSocket connection for the specific market's orderbook feed.\n    *   `on('update', (data) => { ... })`: Emits events on every significant change, such as a new orderbook state or freshly calculated metrics.\n    *   `on('signal', (signal) => { ... })`: Emits higher-level analytical events, such as a \"large trade detected\" or \"liquidity imbalance crossed threshold\" signal.\n    *   Public Getters: It likely exposes methods or properties to retrieve the current state on demand, e.g., `getCurrentOrderbook()`, `getMetrics()`, `getHistoricalData()`.\n*   **Configuration Options:**\n    *   WebSocket endpoint.\n    *   Parameters for metric calculations (e.g., VWAP window size, EMA periods).\n    *   Thresholds for signal generation.\n\n### 3. DEPENDENCIES: What does it depend on?\n\n**External Libraries:**\n*   **`events` (Node.js built-in):** Both `MarketScanner` and `OrderbookEngine` are described as event emitters (explicitly for `MarketScanner`), making this a core dependency for implementing the Observer pattern.\n*   **HTTP Client (e.g., `axios`, `node-fetch`):** The `MarketScanner` needs to fetch the list of all markets from a Polymarket REST or GraphQL API.\n*   **WebSocket Client (e.g., `ws`):** The `OrderbookEngine` requires a WebSocket client to connect to Polymarket's real-time data feeds for orderbook updates.\n*   **Financial/Technical Analysis Library (e.g., `technicalindicators`):** The `OrderbookEngine`'s purpose is to calculate metrics. A dedicated library would be used for calculations like VWAP, moving averages, etc., to avoid reinventing the wheel and ensure accuracy.\n\n**Other Internal Modules:**\n*   **`src/types` or `src/common` (Implicit):** A strong, implicit dependency on a shared types module that defines interfaces like `Market`, `Order`, `Orderbook`, and `ScoredMarket`. This ensures data consistency across the application.\n*   **`src/utils` or `src/lib` (Likely):** A potential dependency on a utility module for common functions like logging, error handling, or rate-limiting API calls.\n*   **No direct dependency on a trading/execution module:** The data flow is one-way out of this module via events. It provides information but does not depend on the modules that consume it.\n\n### 4. DESIGN PATTERNS: What patterns are used?\n\n*   **Observer Pattern:** This is the most prominent pattern, used by both core classes. By extending `EventEmitter`, `MarketScanner` and `OrderbookEngine` act as \"subjects\" that notify \"observers\" (other modules) of state changes (`scanComplete`, `update`, `signal`) without being tightly coupled to them. This is a robust and scalable way to communicate between modules.\n\n*   **Strategy Pattern (Implicit):** The `MarketScanner`'s `calculateMarketScore` method is a prime example of an encapsulated algorithm. While it may be implemented as a private method, it represents a specific \"strategy\" for ranking markets. This design allows the scoring logic to be modified or completely replaced without affecting the rest of the scanner's operation (fetching, filtering). Similarly, the metric calculation logic within `OrderbookEngine` represents a set of analytical strategies.\n\n*   **Facade Pattern (Module-level):** The `src.market` module as a whole acts as a Facade. It provides a simplified, high-level interface (`MarketScanner`, `OrderbookEngine`) to a complex subsystem. It hides the underlying details of interacting with the Polymarket API, managing WebSocket connections, parsing data formats, and performing complex financial calculations. A consumer module"
    },
    {
      "name": "src.strategy",
      "analysis": "Of course. Here is a detailed architectural analysis of the `src.strategy` module.\n\n---\n\n### **1. MODULE RESPONSIBILITY**\n\nThe `src.strategy` module's core responsibility is to **define and implement the decision-making logic for all trading algorithms** within the system.\n\nIt accomplishes this through a two-tiered approach:\n1.  **Framework Definition:** It establishes a standardized contract for what a \"strategy\" is via the abstract `BaseStrategy` class. This ensures that any new trading algorithm will integrate predictably with the rest of the system, handling inputs (market data), processing logic, and outputs (trade signals) in a uniform way.\n2.  **Concrete Implementation:** It provides specific, encapsulated implementations of different trading algorithms, such as `MomentumStrategy` and `SpreadArbitrageStrategy`. Each class contains the unique logic for its respective approach, from data analysis to signal generation.\n\nIn essence, this module is the \"brain\" of the trading operation, determining *when* and *why* to trade, while delegating the *how* (execution) and the *what* (market data) to other modules.\n\n### **2. PUBLIC API**\n\nThe module exposes its functionality primarily through its exported classes, which serve as blueprints and instantiable components for the application's core logic.\n\n*   **Key Classes/Functions:**\n    *   `BaseStrategy` (`src/strategy/baseStrategy.ts`): This is the most critical export for architectural purposes. Other parts of the system will use it for type-hinting and to interact with any strategy object generically, without needing to know its specific implementation. It is not instantiated directly but is extended by all other strategies.\n    *   `MomentumStrategy` (`src/strategy/momentum.ts`): A concrete, instantiable class that can be used by a strategy runner or manager.\n    *   `SpreadArbitrageStrategy` (`src/strategy/spreadArb.ts`): Another concrete, instantiable class available for use.\n\n*   **Entry Points:**\n    The primary interaction pattern with this module's classes involves:\n    1.  **Instantiation:** A higher-level module (e.g., a \"Strategy Manager\") will import a concrete class like `MomentumStrategy` and create an instance, passing in a configuration object.\n    2.  **Evaluation Loop:** The core application loop will feed market data (e.g., new candles, ticks) to the strategy instance, likely by calling a method defined in `BaseStrategy`, such as `evaluate()`.\n    3.  **Event Handling:** Methods like `onOrderFill()` (mentioned in `momentum.ts`) act as reactive entry points. They are called by an external module (like an order execution service) to notify the strategy of state changes, allowing it to update its internal position, P&L, etc.\n\n*   **Configuration Options:**\n    Configuration is managed at the `BaseStrategy` level and extended by subclasses. A consumer of this module would need to provide a configuration object upon instantiation.\n    *   **Common Config (in `BaseStrategy`):** Market symbols, trading account ID, risk parameters (e.g., max position size, stop-loss percentage).\n    *   **Specific Config (in `MomentumStrategy`):** Lookback periods for momentum calculation, RSI thresholds, volume multiplier thresholds.\n    *   **Specific Config (in `SpreadArbitrageStrategy`):** Symbols for the \"YES\" and \"NO\" tokens, the target spread to trigger a trade, minimum liquidity requirements.\n\n### **3. DEPENDENCIES**\n\nWhile not explicitly listed, the purpose and nature of the files imply the following dependencies:\n\n*   **External Libraries:**\n    *   **Technical Analysis Library (e.g., `technicalindicators`, `tulind`):** `MomentumStrategy` would heavily rely on such a library to calculate indicators like RSI, Moving Averages, and Bollinger Bands from historical market data.\n    *   **Logging Library (e.g., `winston`, `pino`):** For structured logging of decisions, errors, and state changes within each strategy.\n    *   **Arbitrary-Precision Math Library (e.g., `decimal.js`, `big.js`):** Essential for financial calculations to avoid floating-point inaccuracies when dealing with prices and quantities.\n\n*   **Other Internal Modules:**\n    *   **`src.types` or `src.shared` (Assumed):** A module defining common data structures used across the application, such as `Candle`, `Order`, `TradeSignal`, and `Fill`. This is crucial for creating a stable interface between modules.\n    *   **`src.marketData` (Assumed):** This module would be a critical dependency, providing the real-time and historical market data (candles, order books) that the `evaluate()` method in each strategy consumes.\n    *   **`src.execution` or `src.broker` (Assumed):** When a strategy generates a signal, it needs to send it somewhere to be executed. This module would be the destination for trade signals. The `onOrderFill` method implies a callback dependency *from* this module *to* the strategy.\n    *   **`src.riskManager` (Assumed):** The `canTrade()` method mentioned in the `BaseStrategy` insights suggests a dependency on a risk management module to check for things like available capital or portfolio-level risk limits before placing a trade.\n\n### **4. DESIGN PATTERNS**\n\nThe module's architecture is heavily influenced by established behavioral design patterns, promoting flexibility and separation of concerns.\n\n*   **Strategy Pattern (Behavioral):** This is the foundational pattern for the entire module.\n    *   **Abstract Strategy:** `BaseStrategy` defines the common interface (`evaluate`, `canTrade`).\n    *   **Concrete Strategies:** `MomentumStrategy` and `SpreadArbitrageStrategy` provide specific, interchangeable implementations of that interface.\n    *   **Context:** A hypothetical \"StrategyRunner\" class outside this module would hold a reference to a `BaseStrategy` object, allowing the running algorithm to be swapped without changing the runner's code.\n\n*   **Template Method Pattern (Behavioral):** The `BaseStrategy` class likely uses this pattern to enforce a consistent execution flow.\n    *   It would define a final public method (e.g., `processTick(tickData)`) that acts as the template.\n    *   Inside this method, it calls the abstract \"primitive\" methods in a specific order: first `evaluate(tickData)`, then `canTrade(signal)`, and finally `emitSignal(validatedSignal)`.\n    *   This ensures all strategies follow the same core steps (evaluate, validate, emit) while allowing each to define the specific logic for those steps.\n\n*   **Observer Pattern (Behavioral):** The `onOrderFill` method in `MomentumStrategy` indicates the use of this pattern.\n    *   **Observer:** The strategy instance itself.\n    *   **Subject:** The order execution module.\n    *   When the subject's state changes (an order is filled), it automatically notifies its observers (the strategies) by calling their `onOrderFill` method, passing data about the fill. This decouples the strategy from needing to poll for order status.\n\n### **5. DATA FLOW**\n\nThe data flow is cyclical, involving inputs, internal processing, and outputs that can trigger new inputs.\n\n1.  **Input Sources:**\n    *   **Market Data:** Real-time or historical data (candles, ticks) flows from a `marketData` module into the strategy's `evaluate` method."
    }
  ],
  "architecture": "Of course. Based on the provided module-level analysis and repository structure, here is a comprehensive architectural analysis.\n\n---\n\n### 1. ARCHITECTURE PATTERN: What is the overall architecture?\n\nThe repository implements a **Modular Monolith** architecture arranged in a **Layered (or N-Tier)** pattern.\n\n**Justification:**\n\n*   **Monolith:** The application is designed to run as a single, self-contained process. The `src/index.ts` file acts as the central entry point that instantiates and orchestrates all other components. There is no indication of separate, independently deployable services (i.e., not microservices).\n*   **Modular:** Despite being a monolith, the architecture is exceptionally well-modularized. Each module (`api`, `market`, `strategy`, `trader`, etc.) has a distinct and well-defined responsibility (high cohesion). The interactions between these modules are managed through clear public APIs, indicating loose coupling. This modularity allows for independent development, testing, and reasoning about different parts of the system.\n*   **Layered:** The modules are organized into clear layers of responsibility, creating a unidirectional flow of dependencies. This is a classic layered architecture designed to separate concerns:\n    *   **Infrastructure Layer (`api`, `config`, `utils`):** Handles communication with external systems (Polymarket API, environment, console).\n    *   **Application/Service Layer (`market`):** Provides services and data analysis that support the core business logic.\n    *   **Domain/Business Logic Layer (`strategy`, `trader`):** Contains the core decision-making and execution logic that defines the bot's purpose.\n\n### 2. LAYER ANALYSIS: What are the architectural layers?\n\nThe system is clearly divided into distinct logical layers, with modules fitting neatly into them.\n\n*   **Presentation/UI Layer:**\n    *   **Component:** The implicit Command Line Interface (CLI) initiated by `src/index.ts`.\n    *   **Responsibility:** This is a headless application (a bot). The \"presentation\" layer is minimal, consisting of the startup mechanism and the logging output managed by the `utils.logger`, which serves as the primary interface for the operator to observe the bot's behavior.\n\n*   **Business Logic Layer (Domain Layer):**\n    *   **Components:** `src.strategy`, `src.trader`.\n    *   **Responsibility:** This is the heart of the application. The `strategy` module encapsulates the \"when\" and \"why\" of trading by analyzing market conditions and generating signals. The `trader` module contains the \"how,\" managing the operational mechanics of risk, positions, and order execution. This layer represents the core business value of the bot.\n\n*   **Application Layer (Service Layer):**\n    *   **Components:** `src.market`, `src`.\n    *   **Responsibility:** This layer supports the business logic. The `market` module acts as a service layer, consuming raw data from the infrastructure layer and transforming it into meaningful intelligence (`MarketScanner`, `OrderbookEngine`) for the `strategy` module to consume. The root `src` module acts as the application's orchestrator or \"composition root,\" wiring all the layers and components together.\n\n*   **Infrastructure Layer (Data Access Layer):**\n    *   **Components:** `src.api`, `src.config`, `src.utils`.\n    *   **Responsibility:** This layer is responsible for all interactions with the outside world.\n        *   `src.api`: The gateway to the external Polymarket service, abstracting away REST and WebSocket communication.\n        *   `src.config`: Interacts with the process environment to load configuration.\n        *   `src.utils`: Provides cross-cutting infrastructure concerns like logging (writing to the console/file) and high-precision math primitives.\n\n### 3. DATA FLOW: How does data flow through the system?\n\nThe system operates on a continuous, event-driven data flow loop.\n\n1.  **Initialization:** The `main()` function in `src/index.ts` is the entry point. It reads configuration via the `config` module and instantiates the main `PolymarketTradingBot`.\n2.  **Market Discovery (Macro Loop):**\n    *   The `MarketScanner` (`market` module) periodically calls the `PolymarketAPI` (`api` module) to fetch a list of all available markets.\n    *   It filters and scores these markets, identifying a small set of \"tradable\" markets.\n3.  **Real-time Data Ingestion (Micro Loop):**\n    *   The main bot subscribes to the orderbooks of these tradable markets via the `PolymarketWebSocket` (`api` module).\n    *   The WebSocket pushes real-time orderbook updates into the system.\n4.  **Analysis & Signal Generation:**\n    *   The `OrderbookEngine` (`market` module) receives these updates, maintains the live orderbook state, and calculates key metrics (VWAP, spread, imbalance).\n    *   It then emits an \"update\" event (Observer Pattern).\n    *   One or more concrete `Strategy` instances (`strategy` module) are subscribed to these events. They analyze the metrics provided by the `OrderbookEngine`.\n    *   If a strategy's conditions are met, it generates a \"trade signal\" (e.g., an object describing a desired buy/sell action).\n5.  **Execution & State Management:**\n    *   The trade signal is passed to the `trader` module.\n    *   The `RiskManager` first validates the signal against predefined risk rules (e.g., max daily loss, exposure). If the check fails, the flow is aborted.\n    *   If approved, the"
}