{
  "modules": [],
  "key_files": [],
  "patterns": [
    "Repository",
    "Observer",
    "Pattern",
    "Factory"
  ],
  "dependencies": {},
  "insights": [
    {
      "area": "root",
      "analysis": "### Comprehensive Analysis of the Directory: `/Users/mkorovkin/Desktop/crypto-docs-mcp/docs-agent-v3/Polymarket-Copy-Trading-Bot`\n\nThis analysis is based on a thorough exploration using the available tools: \n- `tool_get_file_structure` to map the directory tree (revealing a clean, modular TypeScript project under `src/`).\n- `tool_read_file` to inspect key files (README.md, package.json, src/index.ts, src/config/env.ts, src/strategy/baseStrategy.ts, src/strategy/spreadArb.ts, src/api/polymarket.ts, src/trader/orderManager.ts, src/market/marketScanner.ts).\n- `tool_check_language_tools` confirming a Node.js/TypeScript setup with npm as the package manager, no other build tools detected.\n\nThe directory represents a self-contained Node.js/TypeScript project for an automated trading bot targeting Polymarket (a decentralized prediction market platform on the Polygon blockchain, using USDC for trades). The codebase emphasizes modular design, real-time data handling, and risk-controlled execution. However, there's a notable discrepancy between the project name (\"Copy-Trading-Bot\") and README.md (which describes copy trading features like wallet mirroring) versus the actual implementation (which focuses on algorithmic strategies like spread arbitrage and momentum, with no copy trading logic present). This suggests the code may be an early/incomplete version, a fork, or mismatched documentation from a related repo (e.g., the GitHub link in README points to a potentially different implementation).\n\nBelow is a structured breakdown as requested.\n\n#### PURPOSE: What is this directory/module responsible for?\nThis directory implements a production-ready automated trading bot for Polymarket's Central Limit Order Book (CLOB) API. It scans prediction markets (e.g., binary YES/NO outcomes on events like elections or sports), evaluates trading opportunities using configurable strategies, executes limit orders, manages positions, and enforces risk controls. Key goals:\n- **Real-time Monitoring**: Fetches market data via REST API and subscribes to WebSocket orderbook updates for low-latency decisions (e.g., 1-second detection implied in README, though WS details are partial).\n- **Strategy Execution**: Runs pluggable strategies (spread arbitrage between YES/NO tokens and momentum trading) every 10 seconds on filtered markets.\n- **Risk-Averse Trading**: Limits exposure (e.g., max $100/position, $50 daily loss, 1-2% slippage), supports paper trading for testing, and includes circuit breakers/emergency stops.\n- **Lifecycle Management**: Handles bot startup/shutdown, order monitoring, and graceful error recovery.\n- **No Copy Trading**: Despite the name and README, there's no implementation for monitoring/copying external wallets (e.g., no blockchain event listeners for trades). Instead, it's algorithmic trading focused on mispricings and momentum in prediction markets. The bot assumes a Polygon wallet with USDC but uses a centralized API for orders (no direct on-chain signing shown).\n\nThe bot is designed for 24/7 operation on Node.js 18+, with configurable toggles for live vs. paper trading. It targets high-volume, liquid markets resolving within ~1 week to minimize event risk.\n\n#### KEY FILES: Which files are most important and why?\nThe project is organized under `src/` with clear separation of concerns (API, config, market data, strategies, trading execution, utils). Total files: ~20 (mostly .ts modules). Here's the prioritized list based on centrality to functionality:\n\n1. **src/index.ts** (Most Critical - Entry Point): Orchestrates the entire bot. Initializes components (API, WS, scanner, strategies, managers), handles start/stop/emergency shutdown, sets up event handlers, and runs the strategy execution loop. Why? It's the \"glue\" \u2013 without it, nothing runs. Exports `PolymarketTradingBot` class for instantiation. References: Imports from all subdirs; main() function for direct execution.\n\n2. **src/config/env.ts** (Critical - Configuration Layer): Loads/validates .env vars into a typed `EnvConfig` interface (e.g., API keys, risk limits like `MAX_POSITION_USD=100`, strategy flags like `SPREAD_ARB_ENABLED=true`). Uses Decimal.js for precision. Why? Centralizes all tunable params; throws errors on invalid configs (e.g., negative loss limits). Enables paper trading (`ENABLE_PAPER_TRADING=true` default).\n\n3. **src/api/polymarket.ts** (Critical - Data/Execution Gateway): Defines `PolymarketAPI` class (Axios-based REST client) for core interactions: `getActiveMarkets()` (fetches 100+ markets with filters), `getOrderbook()`, `placeOrder()` (limit orders only), `cancelOrder()`, `getPositions()`. Emits events for WS subscriptions. Why? All data and trades flow through here; handles auth via API key/secret. Types like `Market`, `Orderbook`, `Order` ensure type safety.\n\n4. **src/market/marketScanner.ts** (High Importance - Market Discovery): `MarketScanner` class scans active markets every 5 minutes (configurable), filters by volume (`> $1000`), liquidity (`> $500`), time to resolution (`< 168 hours`), and requires YES/NO tokens. Scores markets (0-100) based on volume (40pts max), liquidity (30pts), time (20pts optimal 24-72hrs), activity (10pts bonus). Why? Feeds strategies with \"tradable\" markets (top 10 subscribed via WS); caches results for efficiency.\n\n5. **src/strategy/baseStrategy.ts** (High Importance - Strategy Foundation): Abstract `BaseStrategy` class (EventEmitter) defines the strategy interface: `evaluate(market, orderbook) -> TradeSignal[]` (signals include side, size, price, confidence), `canTrade(market)`, `onOrderFill()`. Validates signals (e.g., non-zero size/price). Why? Enables pluggable strategies; all specific strategies extend it.\n\n6. **src/strategy/spreadArb.ts** (High Importance - Core Strategy Implementation): `SpreadArbitrageStrategy` extends BaseStrategy. Detects YES/NO mispricings (e.g., buy YES if `ask_YES < 1 - bid_NO - 0.1% fee`; min 3% spread). Positions: $10 size, 5min hold, 1% profit target, 2% stop loss. Tracks positions in Map. Why? One of two enabled strategies (per config); exemplifies arb logic. Note: Assumes dual orderbooks but passes single in evaluate() \u2013 potential bug.\n\n7. **src/trader/orderManager.ts** (High Importance - Execution Engine): `OrderManager` places/monitors orders via API, simulates in paper mode (10% random fill chance every 5s). Handles partial/complete fills, timeouts (5min default), cancellations. Integrates risk checks. Why? Turns signals into actions; polls API for fills, emits 'orderFill' events. Stats like open/filled counts.\n\n8. **package.json** (Essential - Dependencies/Build): Defines scripts (`npm start`, `npm run paper` for simulation), deps (axios for HTTP, ws for real-time, decimal.js for finance math, dotenv for env). Dev deps: TypeScript, ESLint, Jest. Why? Reveals runtime needs (Node 18+); no heavy blockchain libs (e.g., ethers.js absent \u2013 API abstracts chain).\n\n9. **README.md** (Important - Documentation): Setup guide, features table, config examples (.env for private key, RPC, wallets \u2013 but code ignores COPY_WALLETS). Mentions MongoDB/P&L (absent in code). Why? User-facing; highlights safety (limit orders, no market orders) but mismatches code (e.g., no copy engine).\n\nOther notables:\n- **src/trader/riskManager.ts** (Inferred): Referenced heavily (e.g., `checkTradeSignal()`, circuit breakers); likely validates sizes/losses.\n- **src/api/websocket.ts** (Inferred): Handles WS for orderbook updates; index.ts initializes `PolymarketWebSocket`.\n- **src/utils/logger.ts** (Utility): Custom logger (possibly Pino-backed); used everywhere for info/warn/error.\n- **tsconfig.json**: Standard TS config (strict mode, ES2020 target).\n\nLess critical: `src/strategy/momentum.ts` (similar to spreadArb, but unread \u2013 likely volume breakout logic), utils/math.ts (Decimal helpers).\n\n#### KEY COMPONENTS: Classes, functions with their roles\n- **PolymarketTradingBot (src/index.ts)**: Core orchestrator (EventEmitter). Roles: Init components, `start()` (WS connect, scan, sync positions, strategy loop every 10s), `stop()` (cancel orders, disconnect), `executeStrategies()` (eval signals, place via OrderManager), `emergencyStop()` (force close). Events: 'started', 'stopped', 'emergencyStop'. Handles SIGINT/SIGTERM for shutdown.\n\n- **PolymarketAPI (src/api/polymarket.ts)**: REST client. Key functions: `getActiveMarkets(limit=100)` (filter active/closed), `placeOrder(marketId, tokenId, side, size, price)` (limit only), `getOrderbook(marketId, tokenId)`, `cancelOrder(id)`, `getPositions()`. Emits 'subscribe'/'unsubscribe' for WS.\n\n- **MarketScanner (src/market/marketScanner.ts)**: Market filterer (EventEmitter). Key functions: `startScanning(interval=300s)` (periodic scan), `scanMarkets()` (fetch/process 200 markets), `analyzeMarket(market)` (filter/score: volume>1000, liquidity>500, time<168h, YES/NO tokens), `getTradableMarkets()` (meetsCriteria=true). Events: 'scanComplete'. Scores: Volume (40pts), liquidity (30pts), time (20pts optimal 24-72h), activity (10pts).\n\n- **BaseStrategy (src/strategy/baseStrategy.ts)**: Abstract strategy base (EventEmitter). Key functions: `evaluate(market: ScannedMarket, orderbook: OrderbookSnapshot) -> TradeSignal[]` (generate buys/sells), `canTrade(market)` (criteria check), `onOrderFill(order)`, `validateSignal(signal)` (size/price/confidence checks). TradeSignal: {marketId, tokenId, side, size(Decimal), price(Decimal), reason, confidence(0-1), timestamp}.\n\n- **SpreadArbitrageStrategy (src/strategy/spreadArb.ts)**: Arb-specific. Key functions: `evaluate()` (calc opportunity: buy YES if profitable after 0.1% fee; check exits for time/profit/stop), `calculateArbitrageOpportunity(yesOB, noOB)` (compares best bid/ask), `canTrade()` (requires YES/NO). Positions tracked in Map; $10 size, 3% min spread, 5min hold.\n\n- **OrderManager (src/trader/orderManager.ts)**: Order lifecycle (EventEmitter). Key functions: `executeSignal(signal)` (risk check, place/simulate, timeout), `cancelOrder(id)`, `cancelAllOrders()`, `handlePartialFill(id, size, price)`, `checkOrderFills()` (poll every 5s or simulate). ManagedOrder: Tracks status (OPEN->FILLED), slippage (1%). Events: 'orderFill', 'orderCancelled', 'orderExpired'.\n\nInferred (from imports/references):\n- **RiskManager (src/trader/riskManager.ts)**: `checkTradeSignal(signal) -> {approved, adjustedSize, reason}`, `recordPosition()`, circuit breaker on losses. Events: 'circuitBreaker', 'dailyStatsUpdate'.\n- **PositionManager (src/trader/positionManager.ts)**: `syncPositions()`, `addOrUpdatePosition()`, `closePosition()`, `forceCloseAllPositions()`.\n- **PolymarketWebSocket (src/api/websocket.ts)**: `connect()`, `subscribe(marketId, tokenId)`, emits 'orderbookUpdate', 'spreadAlert'.\n\n#### PATTERNS: Design patterns, conventions used\n- **Modular/Composition Pattern**: Bot composes managers (e.g., `new OrderManager(api, riskManager)`); subdirs enforce separation (API for I/O, strategy for logic, trader for execution).\n- **Strategy Pattern**: BaseStrategy + concrete classes (SpreadArbitrage, Momentum); enabled via config, evaluated in loop.\n- **Event-Driven/Pub-Sub**: EventEmitter everywhere (e.g., scanner -> bot on 'scanComplete'; orderbook -> positionManager on 'orderbookUpdate'; strategies emit 'signal'). Loose coupling, async flow.\n- **Factory-like Init**: Strategies initialized conditionally (e.g., `if (config.spreadArbEnabled) strategies.push(new SpreadArbitrageStrategy())`).\n- **Adapter/Proxy for API**: PolymarketAPI wraps Axios, adds Decimal conversion, error logging, WS emission.\n- **Simulation/Proxy for Testing**: Paper mode proxies real calls (random fills); no live chain risk.\n- **Conventions**:\n  - TypeScript strict (interfaces like EnvConfig, TradeSignal; Decimal.js for all money/volumes).\n  - Async everywhere (Promises for API/execution).\n  - Validation: Env throws on bad configs; signals validated pre-emit.\n  - Logging: Consistent (logger.info/warn/error); levels via config.\n  - Error Resilience: Try/catch in loops, but some throws (e.g., start()) could crash \u2013 no global handler.\n  - Naming: CamelCase classes/functions, descriptive (e.g., `handleMarketScanComplete(markets)`).\n  - Limits: Hard-coded safeguards (top 10 market subs, 10s strategy interval).\n\n#### DEPENDENCIES: What it imports/uses from elsewhere\n- **External (via package.json)**:\n  - Runtime: `axios` (HTTP client), `ws` (WebSocket), `dotenv` (env loading), `decimal.js` (precise math, used for all prices/sizes), `pino` (likely underlying logger.ts).\n  - No blockchain deps (e.g., no @polygon/web3 \u2013 API abstracts; assumes Polygon RPC in env but unused in code).\n  - Node built-ins: `events` (EventEmitter), `process` (signals).\n- **Internal (self-contained)**:\n  - Cross-module imports: e.g., index.ts imports `./api/polymarket`, `./strategy/spreadArb`; strategies import config/env, utils/logger/math.\n  - No external codebase deps; this dir is standalone (no ../ imports). Utils (logger, math) shared internally.\n  - Env assumes .env file (not in dir; user-provided) with PRIVATE_KEY, POLYMARKET_API_KEY/SECRET, RPC_URL (unused in code).\n- **Implicit**: Polymarket CLOB API (REST/WS endpoints like /markets, /orders); MongoDB mentioned in README but absent (no mongoose import).\n\n#### EXPORTS: What it provides to other modules\n- **Default Exports**: Each .ts module exports one main class (e.g., `export default PolymarketTradingBot;`, `export default SpreadArbitrageStrategy;`).\n- **To Users/External**: The bot as a whole via `npm start` (runs main() in index.ts). Could be imported as a module (e.g., `import PolymarketTradingBot from './src'; const bot = new PolymarketTradingBot(); bot.start();`).\n- **Internal Interfaces/Types**: Reusable like TradeSignal, ScannedMarket, ManagedOrder (exported for type safety across modules).\n- **No Public API**: Primarily a runnable app, not a library. Provides events (e.g., bot.getStatus() for runtime metrics: positions, P&L summary).\n- **Extensibility**: Strategies pluggable (add new extending BaseStrategy); config-driven enables.\n\n#### INSIGHTS: Notable observations, potential issues\n- **Strengths**:\n  - **Robust Risk Design**: Excellent safeguards (limit orders only, slippage protection, daily loss caps, auto-cancel stale orders). Paper mode enables safe testing.\n  - **Efficiency**: Caches scans, subscribes only to top markets, Decimal.js prevents precision errors in finance.\n  - **Real-Time Capable**: WS integration for orderbooks enables fast arb (1s detection per README); event-driven avoids blocking.\n  - **Maintainable**: Clean TS types, modular, ESLint/Jest ready. Graceful shutdown prevents data loss.\n  - **Polymarket Fit**: Tailored for binary markets (YES/NO arb); filters avoid illiquid/resolved events.\n\n- **Discrepancies/Gaps**:\n  - **No Copy Trading**: README promises wallet mirroring (COPY_WALLETS env, 1s detection), but code has zero (no blockchain listeners, no Predictfolio integration). Strategies are pure algo (arb/momentum). This dir may be a \"trading engine\" subset; full copy features possibly in unshown files or another repo.\n  - **Incomplete Features**: No MongoDB/P&L history (README claims it); no backtesting/web dashboard (roadmap items). MomentumStrategy unread but referenced \u2013 assume similar to spreadArb.\n  - **API Assumptions**: Endpoints (e.g., /markets/active) may not match real Polymarket ClobClient (which uses GraphQL/WS for orders). No txn signing (private key in env unused \u2013 API keys suffice?).\n  - **Bugs/Edge Cases**:\n    - SpreadArb `evaluate()` passes single orderbook but needs YES/NO pair (code notes \"would need both\" \u2013 incomplete).\n    - Polling-heavy (5s fill checks) could miss fast fills; WS should handle.\n    - No retry logic for API failures (e.g., rate limits); throws could halt bot.\n    - Simulation in paper mode is basic (random fills) \u2013 not realistic for backtesting.\n    - Security: Env exposes private key (if used); API keys in headers vulnerable to logs.\n  - **Performance**: Scans 200 markets/5min ok for small scale; but 10s strategy loop on top 10 could spike CPU with many signals.\n  - **Testing/Prod Readiness**: Jest present but no tests in code. README setup is 3min but assumes Alchemy/Infura RPC (unused). MIT license allows commercial use.\n  - **Opportunities**: Add copy strategy (extend BaseStrategy with wallet monitoring via Polygon RPC). Integrate real WS fills to reduce polling. Add P&L dashboard as per roadmap.\n\nThis codebase is a strong, risk-focused foundation for Polymarket trading but needs alignment with its \"copy trading\" branding. For production, validate API endpoints and add the missing copy logic. If more files (e.g., momentum.ts, riskManager.ts) are needed, further tool calls could refine this."
    },
    {
      "area": "src",
      "analysis": "### Comprehensive Analysis of the `src` Directory\n\nThe `src` directory serves as the primary source code repository for the Polymarket Copy Trading Bot, a Node.js/TypeScript application designed for automated trading on Polymarket's prediction markets. Below, I provide a thorough breakdown based on the tool explorations (directory structure, file listings, and content reads). The analysis references specific file names, code elements (e.g., classes, methods, variables), and patterns discovered. All files are TypeScript (`.ts`), indicating a compiled-to-JavaScript project likely using `tsc` or a bundler like Webpack/esbuild (though no build config was detected in `src` alone\u2014likely in the project root).\n\n#### PURPOSE: What is this directory/module responsible for?\nThe `src` directory implements the full backend logic for an algorithmic trading bot targeting Polymarket's binary prediction markets (e.g., YES/NO outcomes on events). It handles:\n- **Data Acquisition:** Fetching market data via REST API and real-time orderbook updates via WebSocket.\n- **Market Analysis:** Scanning/filtering active markets, processing orderbooks for metrics like spreads, depth, and momentum.\n- **Strategy Execution:** Running configurable trading strategies (spread arbitrage and momentum) to generate buy/sell signals.\n- **Trading Operations:** Placing/monitoring orders, managing positions, and calculating P&L.\n- **Risk Management:** Enforcing limits (e.g., position size, daily losses) with circuit breakers and cooldowns.\n- **Lifecycle Management:** Starting/stopping the bot, handling events, and graceful shutdowns.\n\nDespite the project name \"Copy Trading Bot,\" the code implements **independent algorithmic strategies** rather than copying trades from specific users/traders (no trader-following API or signals). This may indicate an incomplete feature, a misnomer, or a focus on \"copying\" market inefficiencies (e.g., arb opportunities). The bot supports **paper trading** (simulation mode) for testing and live trading with wallet integration (via private key in env). It runs continuously, scanning markets every 5 minutes and executing strategies every 10 seconds on the top 10 tradable markets. The design emphasizes precision (using `Decimal.js` for financial calcs), event-driven reactivity, and safety (risk controls prevent overexposure).\n\nKey responsibilities by subdirectory:\n- **api/**: External integrations (REST/WS to Polymarket).\n- **config/**: Environment-driven customization.\n- **market/**: Data processing and opportunity detection.\n- **strategy/**: Signal generation.\n- **trader/**: Execution and monitoring.\n- **utils/**: Shared helpers (logging, math).\n- **index.ts**: Orchestration.\n\nThe bot is not a library but a standalone app (runs `main()` on direct invocation), suitable for deployment on a server (e.g., VPS) with Node.js.\n\n#### KEY FILES: Which files are most important and why?\nBased on size, centrality (imports/exports), and role in the core loop (scan \u2192 analyze \u2192 signal \u2192 execute \u2192 monitor), here are the most critical files (prioritized by impact):\n\n1. **index.ts** (12.65 KB) \u2013 **Highest importance (entry/orchestrator).** Defines the `PolymarketTradingBot` class, which ties everything together. Initializes components (e.g., `new PolymarketAPI()`, `new MarketScanner(api)`), wires events (e.g., `marketScanner.on('scanComplete', handleMarketScanComplete)`), and runs the main loop (`executeStrategies()` every 10s). Handles start/stop/emergencyStop, status reporting (`getStatus()`), and process signals (SIGINT/SIGTERM for shutdown). Without this, the bot has no runtime flow. Exports `PolymarketTradingBot` as the public interface.\n\n2. **trader/orderManager.ts** (12.2 KB) \u2013 **Core execution engine.** Manages the full order lifecycle: `executeSignal(signal)` places orders (real or simulated), monitors fills (`checkOrderFills()` every 5s), handles partials/timeouts (`expireOrder()` after 300s), and cancels (`cancelAllOrders()`). Tracks `ManagedOrder` objects with states (PENDING \u2192 FILLED). Integrates risk checks and paper simulation (random 10% fill chance). Critical for turning signals into actions; emits `orderFill` for position updates.\n\n3. **trader/riskManager.ts** (12.03 KB) \u2013 **Safety net.** Implements `checkTradeSignal(signal)` for approvals (e.g., position < $100 USD via `maxPositionUsd`, daily loss < $50 via `maxDailyLossUsd`), circuit breakers (activates on losses, resets in 1h), and cooldowns (5min post-loss). Tracks `DailyStats` (P&L, win rate) with midnight resets. Emits `circuitBreaker` to trigger bot stops. Essential for preventing blowups; used in every trade.\n\n4. **strategy/momentum.ts** (11.9 KB) \u2013 **Key strategy impl.** Extends `BaseStrategy`; `evaluate(market, orderbook)` analyzes price history (20-period EMA via `MathUtils.calculateEMA()`) for breakouts (>2% momentum + 1.5x volume spike), generates `TradeSignal` (e.g., BUY on bullish). Handles trailing stops (5% via `trailingStopPercent`), time limits (10min), profit targets (2x entry threshold). Filters high-volume/liquidity markets. Represents trend-following logic.\n\n5. **trader/positionManager.ts** (11.49 KB) \u2013 **Portfolio tracker.** Syncs positions from API (`syncPositions()`), updates via orderbooks (`updatePositionPrices(snapshot)` for mid-price P&L), adds/closes (`addOrUpdatePosition()`, `closePosition()`). Computes summaries (`getPortfolioSummary()`: total value, win rate). Force-closes in emergencies (`forceCloseAllPositions()`). Integrates with risk manager; emits updates on >$0.10 P&L changes.\n\n6. **market/marketScanner.ts** (6.6 KB) \u2013 **Opportunity discovery.** `scanMarkets()` fetches 200 active markets, filters (volume > $1000, liquidity > $500, 1-168h to resolution), scores (up to 100pts: 40 volume, 30 liquidity, 20 time, 10 activity). Caches tradable ones; runs every 5min. Emits `scanComplete`; bot subscribes to top 10. Gates all strategies.\n\n7. **api/polymarket.ts** (6.65 KB) \u2013 **API gateway.** Axios client for REST (e.g., `getActiveMarkets(limit=100)`, `placeOrder(marketId, side, size, price)`). Defines types (`Market`, `Orderbook`, `Position`). Emits subscribe/unsubscribe for WS. Handles errors (404 for missing markets). Foundation for all data/trades.\n\n8. **strategy/spreadArb.ts** (8.12 KB) \u2013 **Other key strategy.** Extends base; `evaluate()` checks YES+NO prices (buy undervalued if <1-fee via `MathUtils.calculateArbitrage()`), signals BUY ($10 size). Exits on 5min time, 1% profit, or 2% loss. Requires binary tokens. Targets pricing inefficiencies.\n\n9. **market/orderbook.ts** (8.61 KB) \u2013 **Real-time analyzer.** Processes WS data into `OrderbookSnapshot` (spread %, mid-price, imbalance). Detects events (e.g., >3% spread breach via `minSpread`, >50% depth shift). Maintains 100-point price history for volatility (std dev via `MathUtils.calculateStdDev()`). Emits alerts; subscribed post-scan.\n\n10. **config/env.ts** (4.42 KB) \u2013 **Config loader.** Parses `.env` (e.g., `POLYMARKET_API_KEY`, `PRIVATE_KEY`), validates (e.g., `maxDailyLossUsd` negative), defaults (paper=true, minSpread=0.03). Exports `config: EnvConfig`. Drives all behavior; errors halt startup.\n\nSupporting files: `api/websocket.ts` (reconnects, pings every 30s), `utils/logger.ts` (Pino, ISO timestamps), `utils/math.ts` (EMA, arb calcs), `strategy/baseStrategy.ts` (abstract eval/signals).\n\n#### KEY COMPONENTS: Classes, functions with their roles\n- **Classes (Major Ones):**\n  - `PolymarketTradingBot` (index.ts): Orchestrates; roles: init components, `start()` (connect WS, scan, sync positions), `stop()` (cancel orders, disconnect), `executeStrategies()` (loop: get tradable markets \u2192 eval strategies \u2192 place signals), event handling (e.g., `handleOrderFill()` updates positions).\n  - `PolymarketAPI` (api/polymarket.ts): REST client; roles: `getActiveMarkets()` (filter active), `placeOrder()` (limit buys/sells), `getPositions()` (sync portfolio), `subscribeToOrderbook()` (emit for WS).\n  - `PolymarketWebSocket` (api/websocket.ts): WS handler; roles: `connect()` (wss://ws.polymarket.com, backoff reconnect), `subscribe()` (send JSON {type: 'subscribe', channel: 'orderbook'}), `handleOrderbookUpdate()` (emit raw `Orderbook`).\n  - `MarketScanner` (market/marketScanner.ts): Filterer; roles: `scanMarkets()` (API fetch \u2192 process \u2192 score via `calculateMarketScore()`: volume= min(volume/1000,40)), `getTradableMarkets()` (meetsCriteria=true).\n  - `OrderbookEngine` (market/orderbook.ts): Analyzer; roles: `handleOrderbookUpdate()` (create `OrderbookSnapshot`: spread=ask-bid, imbalance=(bidDepth-askDepth)/total), `analyzeOrderbook()` (momentum via 5-pt avg change), emit alerts (e.g., `spreadAlert` if > minSpread*100).\n  - `BaseStrategy` (strategy/baseStrategy.ts): Abstract; roles: `evaluate(market, orderbook)` (return `TradeSignal[]`), `validateSignal()` (size>0, confidence 0-1), `onOrderFill()` (update positions). Extended by strategies.\n  - `SpreadArbitrageStrategy` (strategy/spreadArb.ts): Arb logic; roles: `calculateArbitrageOpportunity()` (if yesAsk <1-noBid-fee, buy YES), `checkExitConditions()` (time<300s, profit>1%).\n  - `MomentumStrategy` (strategy/momentum.ts): Trend follower; roles: `analyzeMomentum()` (EMA via `MathUtils.calculateEMA(prices,10)` >2% threshold), `detectVolumeSpike()` (recentAvg/olderAvg >1.5), trailing stops (update highestPrice, stop= highest*(1-0.05)).\n  - `OrderManager` (trader/orderManager.ts): Executor; roles: `executeSignal()` (risk check \u2192 place/simulate \u2192 setTimeout 300s), `handlePartialFill()` (update remainingSize), `simulateFills()` (paper: random 10-60% partials).\n  - `PositionManager` (trader/positionManager.ts): Tracker; roles: `addOrUpdatePosition()` (avgEntry=weighted), `closePosition()` (realizedPnL=size*(exit-avgEntry)), `getPortfolioSummary()` (totalUnrealizedPnL=sum, winRate=#positive/len).\n  - `RiskManager` (trader/riskManager.ts): Guardian; roles: `checkTradeSignal()` (e.g., exposure<maxPositionUsd, adjust size), `activateCircuitBreaker()` (if dailyPnL < maxDailyLossUsd, emit +1h timeout), `updateDailyStats()` (winRate=#wins/numTrades).\n  - `MathUtils` (utils/math.ts): Helpers; roles: `calculateEMA(values, period)` (multiplier=2/(period+1)), `calculateArbitrage(yes, no, fee)` (total-1-fee), `calculateStdDev(values)` (variance sqrt).\n\n- **Functions/Methods (Key Ones):**\n  - `main()` (index.ts): Instantiates/runs bot, sets global `bot` for signals.\n  - `initializeStrategies()` (index.ts): Adds enabled strategies (e.g., if `spreadArbEnabled`, push `new SpreadArbitrageStrategy()`).\n  - `scanMarkets()` (market/marketScanner.ts): Async fetch/process; `calculateTimeToResolution(endDate)` (hours to ISO date).\n  - `createSnapshot(orderbook)` (market/orderbook.ts): Computes midPrice=(bid+ask)/2, depth=sum top-5 sizes.\n  - `checkTradeSignal(signal)` (trader/riskManager.ts): Returns `{approved, adjustedSize, warnings}` (e.g., if confidence<0.3, warn).\n  - `oddsToProbability(odds)` (utils/math.ts): 1/(odds+1) for market implied probs.\n\n- **Data Structures:**\n  - `TradeSignal` (strategy/baseStrategy.ts): `{marketId, tokenId, side, size:Decimal, price:Decimal, reason, confidence:0-1, timestamp}`.\n  - `OrderbookSnapshot` (market/orderbook.ts): `{bids:[], asks:[], bestBid/Ask, spreadPercent, midPrice, imbalance}`.\n  - `EnvConfig` (config/env.ts): Interface for all params (e.g., `minSpread:Decimal=0.03`).\n  - Maps: `positions:Map<key, PortfolioPosition>`, `snapshots:Map<key, OrderbookSnapshot>` (in-memory state).\n\n#### PATTERNS: Design patterns, conventions used\n- **Event-Driven/Pub-Sub (Observer):** Core pattern; `EventEmitter` everywhere (e.g., bot listens to `orderFill` \u2192 update positions; WS emits 'orderbook' \u2192 engine analyzes \u2192 strategies eval). Loose coupling: components don't call each other directly.\n- **Strategy Pattern:** `BaseStrategy` abstract with `evaluate()` hook; concrete classes (Momentum/SpreadArb) override for specific logic. Enables pluggable algos (add e.g., mean-reversion).\n- **Dependency Injection/Composition:** Bot constructor injects deps (e.g., `OrderManager(api, riskManager)`); no globals beyond logger/config.\n- **Factory-like Config:** `env.ts` builds/validates `config` object; strategies init with params (e.g., `new MomentumStrategy()` pulls from config).\n- **State Machine:** Orders in `ManagedOrder` (PENDING \u2192 OPEN \u2192 PARTIAL/FILLED/CANCELLED/EXPIRED); positions track unrealized P&L.\n- **Template Method:** BaseStrategy's `onOrderFill()` as hook for subclasses.\n- **Conventions:**\n  - **Naming:** CamelCase classes/methods, interfaces prefixed (e.g., `TradeSignal`), Decimal for money/prices.\n  - **Precision:** `Decimal.js` (50-digit precision, ROUND_HALF_UP) avoids JS float issues (e.g., 0.1+0.2=0.30000000000000004).\n  - **Async/Promises:** All API/execution async (e.g., `await placeOrder()`); error propagation via try-catch/throw.\n  - **Intervals/Timeouts:** Node.js timers for polling (e.g., `setInterval(executeStrategies, 10000)`), expirations (`setTimeout(expireOrder, ms)`).\n  - **Validation:** Env checks (e.g., `if maxSpread>1 throw`), signal validation (`validateSignal(): size>0`).\n  - **Paper/Live Toggle:** `if config.enablePaperTrading` branches (simulate vs. real API).\n  - **Logging:** Consistent `logger.info/error` (Pino); levels via `LOG_LEVEL=debug`.\n  - **Type Safety:** Full TS interfaces (e.g., `Market {tokens: Token[]}`); no `any` abuse.\n  - **Cleanup:** `cleanup()` methods clear intervals/maps/listeners (called on stop/shutdown).\n\n#### DEPENDENCIES: What it imports/uses from elsewhere\n- **External Libraries (NPM, inferred from imports):**\n  - `axios`: REST client in `polymarket.ts`.\n  - `ws`: WebSocket in `websocket.ts`.\n  - `decimal.js`: Precision math everywhere (e.g., `new Decimal('0.03')`).\n  - `dotenv`: Env loading in `env.ts`.\n  - `events`: Node.js `EventEmitter` base.\n  - `pino`: Logger in `logger.ts`.\n  - Node.js built-ins: `process` (signals), `setInterval/Timeout` (timers), `Buffer` (WS messages).\n  - No DB/queue (e.g., Redis); all in-memory.\n\n- **Internal Dependencies (Within src):**\n  - **High-Level (index.ts):** Imports all: `./api/polymarket`, `./api/websocket`, `./market/*`, `./strategy/*`, `./trader/*`, `./config/env`, `./utils/logger`.\n  - **Mid-Level:** Strategies import base (`./baseStrategy`), market (`../market/marketScanner`, `../market/orderbook`), utils (`../utils/math`, `../utils/logger`), config (`../config/env`).\n  - **Low-Level:** Trader imports api (`../api/polymarket`), strategies (`../strategy/baseStrategy`), config/utils.\n  - **Market:** Imports api/ws (`../api/*`), config/utils.\n  - **API/WS:** Mutual via events (API emits 'subscribe' \u2192 WS handles); utils/logger.\n  - **Utils:** Standalone, imported everywhere.\n  - **Flow Dependencies:** Scan (marketScanner) \u2192 Subscribe (orderbook engine via WS) \u2192 Eval (strategies on snapshots) \u2192 Check (riskManager) \u2192 Execute (orderManager) \u2192 Update (positionManager).\n  - **External to src:** `.env` file (parent dir for keys); Polymarket API (assumed live endpoints); no other codebase parts (self-contained).\n\nNo circular deps detected; tree-like (utils \u2192 api/market \u2192 strategy/trader \u2192 index).\n\n#### EXPORTS: What it provides to other modules\n- **Primary Export:** `export default PolymarketTradingBot` (index.ts) \u2013 The runnable class; other modules can import/ instantiate for integration (e.g., in tests: `import Bot from './src'; new Bot().start()`).\n- **Internal Exports:** Mostly defaults for classes (e.g., `export default OrderManager`), plus named types/interfaces (e.g., `export interface TradeSignal`, `export { Market } from './api/polymarket'`). Utils export classes/modules (e.g., `export default MathUtils`, `export const logger`).\n- **No Broad Library:** Designed as an app; exports are for internal cohesion or testing. No barrel exports (index.ts doesn't re-export subs). If used as lib, one could add `export * from './trader/orderManager'`.\n- **Events as Interface:** Emits (e.g., bot 'started', strategies 'signal') provide dynamic APIs without direct method calls.\n\n#### INSIGHTS: Notable observations, potential issues\n- **Observations:**\n  - **Strengths:** Robust risk layer (e.g., circuit breaker halts on $50 loss, auto-resets); event-driven for efficiency (no polling for fills\u2014WS + periodic checks). Modular: Add strategy by extending base + toggling env. Paper mode thorough (simulates random fills, timeouts). Math utils tailored to predictions (e.g., `odds"
    }
  ],
  "failed_explorations": []
}